from pathlib import Path
from typing import Any, Dict, Iterator, List, NamedTuple, Optional, Tuple, Type

import base64
import json
import os
import re
import shlex
import types
import urllib.parse

from ..integrity import Integrity
from ..manifest import ManifestGenerator
from ..package import GitSource, LocalSource, Package, PackageSource, ResolvedSource
from ..requests import Requests
from . import LockfileProvider, ModuleProvider, ProviderFactory, RCFileProvider
from .npm import NpmRCFileProvider
from .special import SpecialSourceProvider

GIT_URL_PATTERNS = [
    re.compile(r'^git:'),
    re.compile(r'^git\+.+:'),
    re.compile(r'^ssh:'),
    re.compile(r'^https?:.+\.git$'),
    re.compile(r'^https?:.+\.git#.+'),
]

GIT_URL_HOSTS = ['github.com', 'gitlab.com', 'bitbucket.com', 'bitbucket.org']


class YarnLockfileProvider(LockfileProvider):
    _LOCAL_PKG_RE = re.compile(r'^(?:file|link):')

    def __init__(self) -> None:
        self.version = 1
        self.cacheKey = str()

    @staticmethod
    def is_git_version(version: str) -> bool:
        for pattern in GIT_URL_PATTERNS:
            if pattern.match(version):
                return True
        url = urllib.parse.urlparse(version)
        if url.netloc in GIT_URL_HOSTS:
            return len([p for p in url.path.split('/') if p]) == 2
        return False

    def parse_lockfile(self, lockfile: Path) -> Dict[str, Any]:
        def _iter_lines() -> Iterator[Tuple[int, str]]:
            indent = '  '
            for line in lockfile.open():
                level = 0
                while line.startswith(indent):
                    level += 1
                    line = line[len(indent) :]
                yield level, line.strip()

        root_entry: Dict[str, Any] = {}
        parent_entries = [root_entry]

        for level, line in _iter_lines():
            if line.startswith('#') or not line:
                continue
            assert level <= len(parent_entries) - 1
            parent_entries = parent_entries[: level + 1]
            if line.endswith(':'):
                key = line[:-1]
                child_entry = parent_entries[-1][key] = {}
                parent_entries.append(child_entry)
            else:
                # NOTE shlex.split is handy, but slow;
                # to speed up parsing we can use something less robust, e.g.
                # _key, _value = line.split(' ', 1)
                # parent_entries[-1][self.unquote(_key)] = self.unquote(_value)
                key, *values = shlex.split(line)
                if key.endswith(':'):
                    key = key[:-1]
                parent_entries[-1][key] = values[0] if len(values) == 1 else values

        return root_entry

    def unquote(self, string: str) -> str:
        if string.startswith('"'):
            assert string.endswith('"')
            return string[1:-1]
        else:
            return string

    def process_package_v1(
        self, lockfile: Path, name_line: str, entry: Dict[str, Any]
    ) -> Package:
        assert name_line and entry

        name = self.unquote(name_line.split(',', 1)[0])
        name, version_constraint = name.rsplit('@', 1)

        source: PackageSource
        if self._LOCAL_PKG_RE.match(version_constraint):
            source = LocalSource(path=self._LOCAL_PKG_RE.sub('', version_constraint))
        else:
            if self.is_git_version(entry['resolved']):
                source = self.parse_git_source(version=entry['resolved'])
            else:
                if 'integrity' in entry:
                    integrity = Integrity.parse(entry['integrity'])
                else:
                    integrity = None
                source = ResolvedSource(resolved=entry['resolved'], integrity=integrity)

        return Package(
            name=name, version=entry['version'], source=source, lockfile=lockfile
        )

    def process_package(
        self, lockfile: Path, name_line: str, entry: Dict[str, Any]
    ) -> Optional[Package]:
        assert name_line and entry
        name = self.unquote(name_line).split(',', 1)[0]
        name, _ = name.rsplit('@', 1)

        # ignore patch, it will be generated by yarn
        if name.find('@patch:') != -1:
            return None

        if entry.get('linkType', None) == 'soft':
            return None

        version: str = entry['version']
        resolution: str = entry['resolution']
        resolved: str = f'resolution#{resolution}'
        integrity: Integrity = Integrity(
            algorithm='sha512', digest=entry.get('checksum', self.cacheKey)
        )

        source: PackageSource

        if self.is_git_version(resolved):
            source = self.parse_git_source(version=resolved)
        else:
            source = ResolvedSource(resolved=resolved, integrity=integrity)

        return Package(name=name, version=version, source=source, lockfile=lockfile)

    def process_lockfile(self, lockfile: Path) -> Iterator[Package]:
        lock_dict: Dict[str, Any] = self.parse_lockfile(lockfile)
        if '__metadata' in lock_dict:
            metadata: Dict[str, Any] = lock_dict['__metadata']
            self.version = int(metadata.get('version', 1))
            assert self.version > 0
            if self.version > 1:
                self.cacheKey = metadata['cacheKey']

            lock_dict.pop('__metadata')

        if self.version == 1:
            for name_line, package in lock_dict.items():
                yield self.process_package_v1(lockfile, name_line, package)
        else:
            for name_line, package in lock_dict.items():
                res_package: Optional[Package] = self.process_package(
                    lockfile, name_line, package
                )
                if res_package:
                    yield res_package


class YarnRCFileProvider(RCFileProvider):
    RCFILE_NAME = '.yarnrc'


class YarnModuleProvider(ModuleProvider):
    class Locator(NamedTuple):
        scope: str
        name: str
        reference: str

    _GIT_PROTOCOLS = ['commit', 'head', 'tag', 'semver']

    class GitRepoUrlParts(NamedTuple):
        repo: str
        protocol: Optional[str]
        request: str
        extra: Optional[Dict[str, str]]

    # From https://github.com/yarnpkg/berry/blob/%40yarnpkg/shell%2F3.1.0/packages/yarnpkg-core/sources/structUtils.ts#L412
    _RESOLUTION_RE = re.compile(r'^(?:@([^/]+?)\/)?([^/]+?)(?:@(.+))$')
    # From https://github.com/yarnpkg/berry/blob/%40yarnpkg/shell%2F3.1.0/packages/yarnpkg-core/sources/structUtils.ts#L462
    _REFERENCE_RE = re.compile(
        r'^([^#:]*:)?((?:(?!::)[^#])*)(?:#((?:(?!::).)*))?(?:::(.*))?$'
    )
    # From https://github.com/yarnpkg/yarn/blob/v1.22.4/src/fetchers/tarball-fetcher.js
    _PACKAGE_TARBALL_URL_RE = re.compile(
        r'(?:(@[^/]+)(?:/|%2f))?[^/]+/(?:-|_attachments)/(?:@[^/]+/)?([^/]+)$'
    )

    def __init__(self, gen: ManifestGenerator, special: SpecialSourceProvider) -> None:
        self.gen = gen
        self.special_source_provider = special
        self.mirror_dir = self.gen.data_root / 'yarn-mirror'
        self.mirror_berry_dir = self.mirror_dir / 'global' / 'cache'
        self.mirror_locator_dir = self.mirror_berry_dir / 'locator'
        self.registry = 'https://registry.yarnpkg.com'
        self.has_resolution = False

    def __exit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc_value: Optional[BaseException],
        tb: Optional[types.TracebackType],
    ) -> None:
        self._finalize()

    def get_resolution_from_resolved(self, resolved: str) -> str:
        assert resolved.startswith('resolution#')
        return resolved[len('resolution#') :]

    def get_locator_url(self, locator: Locator) -> str:
        if locator.scope:
            return f'/@{locator.scope}%2f{locator.name}'
        else:
            return f'/{locator.name}'

    def get_locator_from_resolution(self, resolution: str) -> Locator:
        match = self._RESOLUTION_RE.match(resolution)
        assert match
        scope, name, ref = [s or '' for s in match.groups()]
        return self.Locator(scope=scope, name=name, reference=ref)

    def name_base64_locator(self, locator: Locator, resolution: str) -> str:
        return f'{locator.name}-{base64.b64encode(resolution.encode()).decode()}'

    # From https://github.com/yarnpkg/berry/blob/%40yarnpkg/shell%2F3.1.0/packages/plugin-git/sources/gitUtils.ts#L56
    def parse_git_subsequent(self, url: str) -> GitRepoUrlParts:
        repo, subsequent = url.split('#', 1)
        protocol: Optional[str] = None
        request: str = ''
        extra: Dict[str, str] = {}
        if not subsequent:
            return self.GitRepoUrlParts(
                repo=repo, protocol='head', request='HEAD', extra=None
            )
        if re.match(r'^[a-z]+=', subsequent):
            queries = urllib.parse.parse_qs(subsequent)
            for q in queries.keys():
                if q in self._GIT_PROTOCOLS:
                    protocol = q
                    request = queries[q][0]
                else:
                    extra[q] = queries[q][-1]
            if not request:
                protocol, request = 'head', 'HEAD'
            return self.GitRepoUrlParts(
                repo=repo, protocol=protocol, request=request, extra=extra
            )
        else:
            protocol, request = subsequent.split(':', 1)
            if not request:
                protocol, request = None, subsequent
            return self.GitRepoUrlParts(
                repo=repo, protocol=protocol, request=request, extra=None
            )

    async def resolve_source(self, locator: Locator, version: str) -> ResolvedSource:
        data_url = f'{self.registry}{self.get_locator_url(locator)}'
        # NOTE: Not cachable, because this is an API call.
        raw_data = await Requests.instance.read_all(data_url, cachable=False)
        data = json.loads(raw_data)

        assert 'versions' in data, f'{data_url} returned an invalid package index'

        versions = data['versions']
        assert (
            version in versions
        ), f'{locator.name} versions available are {", ".join(versions)}, not {version}'

        dist = versions[version]['dist']
        assert 'tarball' in dist, f'{locator.name}@{version} has no tarball in dist'

        integrity: Integrity
        if 'integrity' in dist:
            integrity = Integrity.parse(dist['integrity'])
        elif 'shasum' in dist:
            integrity = Integrity.from_sha1(dist['shasum'])
        else:
            assert False, f'{locator.name}@{version} has no integrity in dist'

        return ResolvedSource(resolved=dist['tarball'], integrity=integrity)

    async def generate_package(self, package: Package) -> None:
        source = package.source

        if isinstance(source, ResolvedSource):
            if source.resolved.startswith('resolution#'):
                if not self.has_resolution:
                    self.has_resolution = True
                assert source.integrity, f'{source.resolved}'
                resolution = self.get_resolution_from_resolved(source.resolved)
                locator = self.get_locator_from_resolution(resolution)
                if YarnLockfileProvider.is_git_version(locator.reference):
                    filename = f'{self.name_base64_locator(locator, "git")}-{source.integrity.digest[:10]}.git'
                    git_parts = self.parse_git_subsequent(locator.reference)
                    repo_dir = self.gen.tmp_root / locator.name
                    if git_parts.protocol == 'commit' or git_parts.protocol == None:
                        self.gen.add_git_source(
                            git_parts.repo,
                            commit=git_parts.request,
                            destination=repo_dir,
                        )
                    elif git_parts.protocol == 'tag':
                        self.gen.add_git_source(
                            git_parts.repo, tag=git_parts.request, destination=repo_dir
                        )
                    else:
                        assert (
                            False
                        ), f'Not supported git protocol: {git_parts.protocol}'
                    repo_dir_rel = os.path.relpath(repo_dir, self.mirror_berry_dir)
                    self.gen.add_data_source(
                        json.dumps(
                            {
                                'repo_dir_rel': repo_dir_rel,
                                'resolution': resolution,
                                'checksum': source.integrity.digest,
                            }
                        ),
                        destination=self.mirror_locator_dir / filename,
                    )
                else:
                    filename = f'{self.name_base64_locator(locator, resolution)}-{source.integrity.digest[:10]}.tgz'
                    resolved_source = await self.resolve_source(
                        locator, package.version
                    )
                    assert resolved_source.integrity
                    self.gen.add_url_source(
                        resolved_source.resolved,
                        resolved_source.integrity,
                        self.mirror_locator_dir / filename,
                    )
            else:
                integrity = await source.retrieve_integrity()
                url_parts = urllib.parse.urlparse(source.resolved)
                match = self._PACKAGE_TARBALL_URL_RE.search(url_parts.path)
                if match is not None:
                    scope, filename = match.groups()
                    if scope:
                        filename = f'{scope}-{filename}'
                else:
                    filename = os.path.basename(url_parts.path)

                self.gen.add_url_source(
                    source.resolved, integrity, self.mirror_dir / filename
                )

        elif isinstance(source, GitSource):
            repo_name = urllib.parse.urlparse(source.url).path.split('/')[-1]
            name = f'{repo_name}-{source.commit}'
            repo_dir = self.gen.tmp_root / name
            target_tar = os.path.relpath(self.mirror_dir / name, repo_dir)

            self.gen.add_git_source(source.url, source.commit, repo_dir)
            self.gen.add_command(f'mkdir -p {self.mirror_dir}')
            self.gen.add_command(
                f'cd {repo_dir}; git archive --format tar -o {target_tar} HEAD'
            )

        elif isinstance(source, LocalSource):
            assert (package.lockfile.parent / source.path / 'package.json').is_file()

        else:
            raise NotImplementedError(
                f'Unknown source type {source.__class__.__name__}'
            )

        await self.special_source_provider.generate_special_sources(package)

    def _finalize(self) -> None:
        if not self.has_resolution:
            return

        with open(Path(__file__).parents[1] / 'flatpak-yarn.js', mode='r') as f:
            yarn2_plugin_source = f.read()
            js_dest = self.gen.data_root / 'flatpak-yarn.js'
            self.gen.add_data_source(yarn2_plugin_source, destination=js_dest)


class YarnProviderFactory(ProviderFactory):
    def __init__(self) -> None:
        pass

    def create_lockfile_provider(self) -> YarnLockfileProvider:
        return YarnLockfileProvider()

    def create_rcfile_providers(self) -> List[RCFileProvider]:
        return [YarnRCFileProvider(), NpmRCFileProvider()]

    def create_module_provider(
        self, gen: ManifestGenerator, special: SpecialSourceProvider
    ) -> YarnModuleProvider:
        return YarnModuleProvider(gen, special)
